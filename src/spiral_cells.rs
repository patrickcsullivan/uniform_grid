use itertools::Itertools;
use serde::{Deserialize, Serialize};
use std::{ops::Neg, path::Path, vec};

use crate::offset3::Offset3;

#[derive(Debug, Clone, Copy, Deserialize, Serialize)]
pub struct SpiralCell {
    /// 3-dimensional index of the cell in a 3-dimensional grid.
    pub offset: Offset3,

    /// Index into the last cell in a vector of sorted `SpiralCell`s
    /// that could possibly contain points that are closer to the origin than
    /// points in this cell.
    pub stop_cell_index1: usize,
}

/// Returns a vector of `SpiralCell`s sorted by each cell's distance to the
/// origin, as measured from each cell's closest corner to the origin.
///
/// The cells in the vector are sorted in such a way that they "spiral" out from
/// the origin.
///
/// Each cell in the vector is associated with a `stop_cell_index`. The index
/// points the last cell in the vector that could possibly contain points that
/// are closer to the origin than points in the current cell.
///
/// The `stop_cell_index` is useful when searching for points closest to the
/// origin because if we find a point in some cell, then the `stop_cell_index`
/// tells us the index of the last cell that could possibly contain points that
/// are even closer to the origin. Therefore, after a first point is found in
/// some cell, the cell at `stop_cell_index` is the last cell whose points need
/// to be checked before the search can be terminated.
pub fn spiral_cells(width: usize) -> Vec<SpiralCell> {
    let mut offsets = wedge_offsets(width);
    offsets.sort_by_key(|c| closest_to_origin2(*c));
    offsets
        .iter()
        .enumerate()
        .map(|(i, c)| SpiralCell {
            offset: *c,
            stop_cell_index1: find_stop_cell_index(&offsets, i, *c),
        })
        .collect()
}

pub fn read<P: AsRef<Path>>(path: P) -> Vec<SpiralCell> {
    let encoded = std::fs::read(path).unwrap();
    bincode::deserialize(&encoded[..]).unwrap()
}

/// Returns the offsets of all grid cells where 0 <= x <= y <= z <= `width`.
fn wedge_offsets(width: usize) -> Vec<Offset3> {
    let width = width as i64;
    (0..width)
        .into_iter()
        .flat_map(|x| (x..width).flat_map(move |y| (y..width).map(move |z| Offset3::new(x, y, z))))
        .collect_vec()
}

/// Finds the index of the "stop cell" for the given "start cell".
///
/// The "stop cell" for a given "start cell" is the last cell in `sorted_coords`
/// that could possibly contain points that are closer to the origin than points
/// in the "start cell".
///
/// * `sorted_coords` - Vector of cells sorted by each cell's distance to the
///   origin, as measured from each cell's closest corner to the origin.
/// * `stop_cell_index` - Index into `sorted_coords` of the "start cell".
/// * `stop_cell_coord` - Coordinates of the "start cell".
fn find_stop_cell_index(
    sorted_cell_offsets: &[Offset3],
    start_cell_index: usize,
    start_cell_coord: Offset3,
) -> usize {
    match find_first_out_of_range(
        sorted_cell_offsets,
        start_cell_index + 1,
        furthest_to_origin2(start_cell_coord),
    ) {
        Some(i) => i - 1,
        None => sorted_cell_offsets.len() - 1,
    }
}

/// Returns the index of the first cell whose closest point to the origin is
/// greater than the given squared distance.
fn find_first_out_of_range(
    sorted_cell_offsets: &[Offset3],
    start_cell_index: usize,
    dist2: i64,
) -> Option<usize> {
    sorted_cell_offsets
        .iter()
        .enumerate()
        .skip(start_cell_index)
        .find(|(_i, c)| closest_to_origin2(**c) > dist2)
        .map(|(i, _c)| i)
}

/// Given an offset from a spiral cell, returns all unique variations of the
/// offset that can be generated by permuting and negating components of the
/// offset.
///
/// When a spiral cell table is created, cells are only generated for offsets
/// where 0 <= x <= y <= z, so the table's cells only cover a "wedge" of
/// 3-dimensional space around the "origin cell" at (0, 0, 0). For each spiral
/// cell's offset, we can use this function to generate the offsets of other
/// cells that are the same distance from the "origin cell". (Here, distance is
/// measured from the corner of the spiral cell that is closed to the "origin
/// cell" to the corner of the "origin cell" that is furthest from the spiral
/// cell.)
pub fn offset_variations(cell_offset: Offset3) -> Vec<Offset3> {
    [
        cell_offset.x as i64,
        cell_offset.y as i64,
        cell_offset.z as i64,
    ]
    .iter()
    .permutations(3)
    .map(|cell_offset_compoonents| {
        Offset3::new(
            *cell_offset_compoonents[0],
            *cell_offset_compoonents[1],
            *cell_offset_compoonents[2],
        )
    })
    .flat_map(negations)
    .unique()
    .collect_vec()
}

/// Returns all variations of the offset that can be generated by negating it's
/// components.
fn negations(offset: Offset3) -> Vec<Offset3> {
    vec![
        Offset3::new(offset.x, offset.y, offset.z),
        Offset3::new(offset.x, offset.y, offset.z.neg()),
        Offset3::new(offset.x, offset.y.neg(), offset.z),
        Offset3::new(offset.x, offset.y.neg(), offset.z.neg()),
        Offset3::new(offset.x.neg(), offset.y, offset.z),
        Offset3::new(offset.x.neg(), offset.y, offset.z.neg()),
        Offset3::new(offset.x.neg(), offset.y.neg(), offset.z),
        Offset3::new(offset.x.neg(), offset.y.neg(), offset.z.neg()),
    ]
}

/// Returns the squared distance between the origin and the cell's closest
/// corner to the origin.
///
/// This assumes that all components of `cell_offset` are non-negative, which
/// should be the case when constructing a spiral cell table.
pub fn closest_to_origin2(cell_offset: Offset3) -> i64 {
    to_origin2(cell_offset.x, cell_offset.y, cell_offset.z)
}

/// Returns the squared distance between the origin and the cell's furthest
/// corner from the origin.
///
/// This assumes that all components of `cell_offset` are non-negative, which
/// should be the case when constructing a spiral cell table.
pub fn furthest_to_origin2(cell_offset: Offset3) -> i64 {
    to_origin2(cell_offset.x + 1, cell_offset.y + 1, cell_offset.z + 1)
}

/// Returns the squared distance between the origin and the given point in
/// 3-dimensional space.
#[inline(always)]
fn to_origin2(x: i64, y: i64, z: i64) -> i64 {
    x * x + y * y + z * z
}
